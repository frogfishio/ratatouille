# Ratatouille Cluster

## Introduction

The Ratatouille Cluster is a next-generation logging infrastructure designed around the philosophy of ephemeral-first logging. At its heart is *Ratatoui*, a live, interactive UI that lets operators dynamically choose what to listen to in the vast chatter of logs produced by modern applications.

Traditional logging systems treat logs as transactions to be stored forever, resulting in heavy storage costs and misalignment with how developers actually debug and operate their systems. Ratatouille flips this ontology: everything is ephemeral by default, and the infrastructure decides what is important enough to capture and retain.

Unlike `debug`, which is purely developer-driven, Ratatouille shifts control to operators, allowing them to decide in real-time what logs to capture and retain. However, it can also be used in the same way as `debug` for local debugging, making it a near drop-in replacement. Additionally, Ratatouille supports relays that enable logs to participate seamlessly in the larger logging infrastructure, bridging the gap between developer convenience and operational control.

## Philosophy

**"Don’t be careful what you log. Be careful what you listen to."**

Logs are not sacred records but ephemeral chatter. Developers should feel free to log anything — from structured events to haikus — without worrying about storage or cost. Operators, not developers, decide in real-time what logs to capture, process, and persist. This approach reduces noise, storage overhead, and operational complexity.

## Concepts

- **Topics**: Free-form labels or categories for logs; developers can log anything under any topic.
- **Relays**: Lightweight agents that forward logs from applications to collectors over fast TCP or fallback HTTPS.
- **Collectors**: Core components that aggregate, filter, and process logs; can form hierarchies and scale horizontally.
- **Listeners**: Components that consume processed streams, apply triggers and filters, and forward data to storage or alerting systems.
- **Ratatoui UI**: A matrix-style live console UI for operators to interactively explore and control the log streams.

## Architecture

```
Apps → Relay (fast TCP / slow HTTPS) → Iron/Core Collector → Listener → Triggers/Filters → DB / Grafana / Notifications
```

- Applications emit logs tagged with topics.
- Relays queue and forward logs non-blockingly, handling backpressure by dropping frames or parts gracefully.
- Collectors fan-in/fan-out logs, forming hierarchical topologies suitable for Nomad and Consul service discovery.
- Listeners apply triggers to match, transform, and act on log streams.
- Operators use Ratatoui UI to dynamically explore logs and adjust triggers.

## Components

### Topics

- Developers can freely define topics to categorize logs.
- Topics support any content — structured data, free text, or even creative expressions like haikus.

### Relays

- Non-blocking forwarders that queue logs locally.
- Use fast TCP for low-latency forwarding; fallback to HTTPS when necessary.
- Handle backpressure by dropping frames or parts instead of blocking applications.

### Collectors

- Aggregate logs from multiple relays.
- Support fan-in/fan-out and hierarchical arrangements.
- Designed to work well with Nomad and Consul for service discovery.
- Provide hooks for filtering and transforming logs before forwarding.

### Listeners

- Consume streams from collectors.
- Apply triggers that match log patterns, transform data (e.g., redact, hash, truncate), and then act.
- Actions include persisting to databases, forwarding to Grafana, or sending notifications.

### Ratatoui UI

- Live, matrix-style console for operators.
- Enables real-time exploration and control of log streams.
- Operators can create, modify, and disable triggers on the fly.

## Data Model

Logs are organized around **topics** — free-form labels that group related chatter. Each log message is ephemeral by default and flows through the system until it is either discarded or captured by a listener trigger.

Transforms applied before persistence include:

- Redaction of sensitive data
- Hashing of identifiers
- Truncation of large payloads

## Triggers & Filters

- Triggers match log entries based on patterns or conditions.
- Filters transform matched logs before acting.
- Actions can include storing logs, sending alerts, or updating dashboards.
- Enables burst detection, anomaly detection, and other operational insights.

## Deployment

- Node collectors run on each host, forwarding logs to iron and core collectors.
- Supports Nomad and Consul for dynamic service discovery.
- TLS is optional; VLAN networking can be used to secure traffic.
- Designed with ephemeral-first principles to minimize overhead and maximize flexibility.

## Use Cases

- **Development mode**: Use a DEBUG-like environment variable to log verbosely without worrying about storage.
- **Production mode**: Set a COLLECTOR environment variable to stream logs to the cluster.
- **File tailers**: Rust-based tailers ingest logs from nginx, httpd, and other sources.
- **Burst detection**: Triggers detect unusual spikes and forward metrics to InfluxDB and Grafana.
- **Notifications**: Alerts sent based on trigger conditions.

## Roadmap

- Enhance Ratatoui UI with customizable dashboards and visualizations.
- Improve trigger language expressiveness and performance.
- Add integrations with popular alerting and observability platforms.
- Expand support for cloud-native deployments and Kubernetes.

## License

This project is licensed under the [GPL-3.0-only License](https://spdx.org/licenses/GPL-3.0-only.html).
